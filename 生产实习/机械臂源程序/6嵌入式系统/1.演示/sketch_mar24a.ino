
#include <Arduino.h>
#include <U8g2lib.h>

#ifdef U8X8_HAVE_HW_SPI
#include <SPI.h>
#endif
#ifdef U8X8_HAVE_HW_I2C
#include <Wire.h>
#endif
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
///////////////////////////////////////////////////////////////////////////////////////
#include <dht11.h>
dht11 DHT;
#define DHT11_PIN 23
///////////////////////////////////////////////////////////////////////////////////////
#include <Servo.h>

Servo myservo1, myservo2; // 定义Servo对象来控制
int pos = 0;    // 角度存储变量
int DJ_X = 8, DJ_Y = 9;
///////////////////////////////////////////////////////////////////////////////////////
#include "DFRobot_BMP280.h"
#include "Wire.h"

typedef DFRobot_BMP280_IIC    BMP;    // ******** use abbreviations instead of full names ********

BMP   bmp(&Wire, BMP::eSdoLow);

#define SEA_LEVEL_PRESSURE    1015.0f   // sea level pressure

void printLastOperateStatus(BMP::eStatus_t eStatus)
{
  switch (eStatus) {
    case BMP::eStatusOK:    Serial.println("everything ok"); break;
    case BMP::eStatusErr:   Serial.println("unknow error"); break;
    case BMP::eStatusErrDeviceNotDetected:    Serial.println("device not detected"); break;
    case BMP::eStatusErrParameter:    Serial.println("parameter error"); break;
    default: Serial.println("unknow status"); break;
  }
}
///////////////////////////////////////////////////////////////////////////////////////
#include <Wire.h>
#include "MAX30105.h"

#include "heartRate.h"

MAX30105 particleSensor;

const byte RATE_SIZE = 4; //Increase this for more averaging. 4 is good.
byte rates[RATE_SIZE]; //Array of heart rates
byte rateSpot = 0;
long lastBeat = 0; //Time at which the last beat occurred

float beatsPerMinute;
int beatAvg;
///////////////////////////////////////////////////////////////////////////////////////
int LED1 = 11;
int LED2 = 12;
int LED3 = 13;
int KEY1 = 4;
int KEY2 = 5;
int KEY3 = 6;
int BEEP = 7;
int FAN = 10;
int SENY = A11;
int LIANDU = A5;
int leida = 22;
int huoyan = A10;
int qiti = A9;
///////////////////////////////////////////////////////////////////////////////////////
#define ECHOPIN 53// Pin to receive echo pulse
#define TRIGPIN A0// Pin to send trigger pulse
int distance;
///////////////////////////////////////////////////////////////////////////////////////

int mos = 1;
int zx = 0;
int mos_m = 8; //多少个模式


int DSP = 0;
int vai = 0;

int js = 10;
int sunxu = 0;
///////////////////////////////////////////////////////////////////////////////////////
# include "DFRobot_LedDisplayModule.h"
/*DFRobot_LedDisplayModule Constructor
  Parameter &wire  Wire
  Parameter: The IIC address in default is 0x48
*/
DFRobot_LedDisplayModule LED(Wire, 0x48);

///////////////////////////////////////////////////////////////////////////////////////
#include "I2Cdev.h"
#include "MPU6050_6Axis_MotionApps20.h"

#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
#include "Wire.h"
#endif

MPU6050 mpu;
//MPU6050 mpu(0x69); // <-- use for AD0 high
#define OUTPUT_READABLE_YAWPITCHROLL

#define INTERRUPT_PIN 50  // use pin 2 on Arduino Uno & most boards

bool blinkState = false;

// MPU control/status vars
bool dmpReady = false;  // set true if DMP init was successful
uint8_t mpuIntStatus;   // holds actual interrupt status byte from MPU
uint8_t devStatus;      // return status after each device operation (0 = success, !0 = error)
uint16_t packetSize;    // expected DMP packet size (default is 42 bytes)
uint16_t fifoCount;     // count of all bytes currently in FIFO
uint8_t fifoBuffer[64]; // FIFO storage buffer

// orientation/motion vars
Quaternion q;           // [w, x, y, z]         quaternion container
VectorInt16 aa;         // [x, y, z]            accel sensor measurements
VectorInt16 aaReal;     // [x, y, z]            gravity-free accel sensor measurements
VectorInt16 aaWorld;    // [x, y, z]            world-frame accel sensor measurements
VectorFloat gravity;    // [x, y, z]            gravity vector
float euler[3];         // [psi, theta, phi]    Euler angle container
float ypr[3];           // [yaw, pitch, roll]   yaw/pitch/roll container and gravity vector

// packet structure for InvenSense teapot demo
uint8_t teapotPacket[14] = { '$', 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0x00, 0x00, '\r', '\n' };


volatile bool mpuInterrupt = false;     // indicates whether MPU interrupt pin has gone high
void dmpDataReady() {
  mpuInterrupt = true;
}
///////////////////////////////////////////////////////////////////////////////////////

float cube[8][3] = {{ -15, -15, -15}, { -15, 15, -15}, {15, 15, -15}, {15, -15, -15}, { -15, -15, 15}, { -15, 15, 15}, {15, 15, 15}, {15, -15, 15}}; //立方体各点坐标
int lineid[] = {1, 2, 2, 3, 3, 4, 4, 1, 5, 6, 6, 7, 7, 8, 8, 5, 8, 4, 7, 3, 6, 2, 5, 1}; //记录点之间连接顺序

float* matconv(float* a, float b[3][3]) { //计算矩阵乘法
  float res[3];
  for (int i = 0; i < 3; i++)
    res[i] = b[i][0] * a[0] + b[i][1] * a[1] + b[i][2] * a[2];
  for (int i = 0; i < 3; i++)a[i] = res[i];
  return a;
}

void rotate(float* obj, float x, float y, float z) { //旋转该向量
  x /= PI; y /= PI; z /= PI;
  float rz[3][3] = {{cos(z), -sin(z), 0}, {sin(z), cos(z), 0}, {0, 0, 1}};
  float ry[3][3] = {{1, 0, 0}, {0, cos(y), -sin(y)}, {0, sin(y), cos(y)}};
  float rx[3][3] = {{cos(x), 0, sin(x)}, {0, 1, 0}, { -sin(x), 0, cos(x)}};
  matconv(matconv(matconv(obj, rz), ry), rx);
}

///////////////////////////////////////////////////////////////////////////////////////
const unsigned char logo[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\比邻星.bmp  --*/
  /*--  宽度x高度=128x34  --*/
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xFC, 0xF0, 0x01, 0xFC, 0xF1, 0x0F, 0xFF, 0xFF, 0xC7, 0x7F, 0xE0, 0xC1, 0x03, 0x1F, 0x00,
  0x00, 0xF8, 0xF0, 0x01, 0xFC, 0xF9, 0x0F, 0xFF, 0xFF, 0xC3, 0x7F, 0xE7, 0xC1, 0x03, 0x0F, 0x00,
  0x00, 0x7C, 0xF0, 0x01, 0xDE, 0x79, 0x0F, 0xFF, 0xFF, 0xC3, 0x7F, 0xEF, 0xF1, 0xF7, 0xFF, 0x00,
  0x00, 0x7C, 0xF0, 0x01, 0xCE, 0x7B, 0x0F, 0xFF, 0xFC, 0x03, 0x0F, 0xEF, 0xF1, 0xF7, 0xFF, 0x00,
  0x00, 0x7C, 0xF0, 0x3F, 0xAF, 0x7B, 0x07, 0x3F, 0xF0, 0xC3, 0x7F, 0xFF, 0xF9, 0x87, 0x0F, 0x00,
  0x00, 0xFC, 0xF7, 0x9F, 0xBF, 0x3F, 0x07, 0xFF, 0xFE, 0xE3, 0x7F, 0xF0, 0xE0, 0x81, 0x0F, 0x00,
  0x00, 0xFC, 0xF7, 0x8F, 0xF3, 0xBF, 0x87, 0xFF, 0xFE, 0xE3, 0xFF, 0xF7, 0xE0, 0xF9, 0x7F, 0x00,
  0x00, 0x7C, 0xF0, 0x00, 0x00, 0xBC, 0x07, 0xC1, 0x07, 0x80, 0xAF, 0xF7, 0xE0, 0xFB, 0x7F, 0x00,
  0x00, 0x3C, 0xF8, 0x80, 0xFF, 0xBF, 0x07, 0xFF, 0xFF, 0xE1, 0xBF, 0xF7, 0xE0, 0x03, 0x78, 0x00,
  0x00, 0x3E, 0xF8, 0x80, 0xFF, 0x3F, 0x87, 0xFF, 0xFF, 0xE1, 0x3F, 0xF0, 0xF9, 0xFB, 0x7C, 0x00,
  0x00, 0x3E, 0xF8, 0x00, 0xE0, 0xBD, 0x87, 0xFF, 0xFF, 0xE1, 0x3F, 0xFF, 0xF9, 0xF1, 0x3F, 0x00,
  0x00, 0x3E, 0xF8, 0x80, 0xE7, 0xBC, 0x87, 0xE3, 0x07, 0xF0, 0xBF, 0xFF, 0xF9, 0xE1, 0x1F, 0x00,
  0x00, 0x3E, 0xF8, 0x00, 0xFF, 0x9C, 0x83, 0xFF, 0xFF, 0xF1, 0xFF, 0x7F, 0xF0, 0xC0, 0x0F, 0x00,
  0x00, 0x3E, 0xF8, 0x00, 0x7E, 0xDC, 0x83, 0xFF, 0xFF, 0xF1, 0x3F, 0x78, 0xF0, 0xE0, 0x07, 0x00,
  0x00, 0xFE, 0xFB, 0x1F, 0x3E, 0xDE, 0xC3, 0xFF, 0xFF, 0xF1, 0x3F, 0x78, 0xF0, 0xF0, 0x0F, 0x00,
  0x00, 0xFE, 0xFF, 0x0F, 0x3C, 0x1E, 0xE0, 0xFF, 0xFF, 0xF3, 0x1F, 0x78, 0xF8, 0xF8, 0x1F, 0x00,
  0x00, 0x1F, 0xFC, 0x0F, 0x78, 0x1E, 0xC0, 0xFF, 0xFF, 0x81, 0x03, 0x78, 0x7C, 0x3E, 0x3E, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};

const unsigned char co1[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\1红绿灯.bmp  --*/
  /*--  宽度x高度=32x32  --*/
  0x00, 0xFE, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x80, 0xFF, 0xFF, 0x01, 0x80, 0xFF, 0xFF, 0x01,
  0xFC, 0x3F, 0xFC, 0x3F, 0xFC, 0x1F, 0xF8, 0x3F, 0xF8, 0x0F, 0xF0, 0x1F, 0xF0, 0x0F, 0xF0, 0x0F,
  0xE0, 0x1F, 0xF8, 0x07, 0x80, 0x1F, 0xF8, 0x01, 0x80, 0x7F, 0xFE, 0x01, 0x80, 0xFF, 0xFF, 0x01,
  0xBC, 0x7F, 0xFE, 0x3F, 0xFC, 0x1F, 0xF8, 0x3F, 0xFC, 0x1F, 0xF8, 0x3F, 0xF8, 0x0F, 0xF0, 0x1F,
  0xF0, 0x0F, 0xF0, 0x0F, 0xC0, 0x1F, 0xF8, 0x03, 0x80, 0x3F, 0xFC, 0x01, 0x80, 0x7F, 0xFE, 0x01,
  0x80, 0xFF, 0xFF, 0x01, 0xFC, 0x3F, 0xFC, 0x3F, 0xFC, 0x1F, 0xF8, 0x3F, 0xFC, 0x1F, 0xF8, 0x3F,
  0xF8, 0x0F, 0xF0, 0x1F, 0xF0, 0x0F, 0xF0, 0x0F, 0xC0, 0x1F, 0xF8, 0x03, 0x80, 0x3F, 0xFC, 0x01,
  0x80, 0xFF, 0xFF, 0x01, 0x80, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0x7F, 0x00,
};
const unsigned char co2[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\风扇.bmp  --*/
  /*--  宽度x高度=32x32  --*/
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xC0, 0x03, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xE0, 0x07, 0x00,
  0x00, 0xE0, 0x07, 0x00, 0x00, 0xE0, 0x27, 0x00, 0x00, 0xE0, 0x47, 0x00, 0x00, 0xE0, 0x47, 0x00,
  0x00, 0xE1, 0x87, 0x00, 0x00, 0x21, 0x04, 0x00, 0x80, 0x90, 0x09, 0x01, 0x00, 0x50, 0x0A, 0x00,
  0x00, 0x5C, 0x3A, 0x00, 0x00, 0x9F, 0xF9, 0x00, 0xC0, 0x3F, 0xFC, 0x03, 0xE0, 0xFF, 0xFF, 0x07,
  0xE0, 0x1F, 0xF8, 0x07, 0xE0, 0x0F, 0xF0, 0x07, 0xE0, 0x03, 0xC0, 0x07, 0x00, 0x00, 0x04, 0x00,
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};
const unsigned char co3[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\环境监控.bmp  --*/
  /*--  宽度x高度=32x32  --*/
  0x00, 0x80, 0x01, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x30, 0x07, 0x00, 0x00, 0x18, 0x0D, 0x00,
  0x00, 0x18, 0x19, 0x00, 0x00, 0x0C, 0x31, 0x00, 0x00, 0x06, 0x31, 0x00, 0x00, 0x06, 0x61, 0x00,
  0x00, 0x03, 0x71, 0x00, 0x00, 0x01, 0xD9, 0x00, 0x80, 0x01, 0x8F, 0x00, 0x80, 0x83, 0x83, 0x01,
  0x80, 0x86, 0x01, 0x01, 0xC0, 0x0C, 0x01, 0x03, 0xC0, 0x18, 0x01, 0x03, 0x40, 0x70, 0x01, 0x03,
  0x40, 0xC0, 0xC1, 0x03, 0x40, 0x80, 0x61, 0x02, 0x40, 0x80, 0x31, 0x02, 0x40, 0x00, 0x1D, 0x02,
  0x40, 0x00, 0x07, 0x02, 0xC0, 0x80, 0x03, 0x02, 0x80, 0x00, 0x01, 0x03, 0x80, 0x01, 0x01, 0x01,
  0x00, 0x03, 0x81, 0x01, 0x00, 0x0E, 0xC1, 0x00, 0x00, 0xF8, 0x3F, 0x00, 0x00, 0xC0, 0x0F, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,

};
const unsigned char co4[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\i-心率.bmp  --*/
  /*--  宽度x高度=32x32  --*/
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x07, 0xE0, 0x03, 0xF0, 0x1E, 0x78, 0x0F,
  0x18, 0x30, 0x0C, 0x18, 0x0C, 0x60, 0x06, 0x30, 0x06, 0xC0, 0x03, 0x60, 0x02, 0x80, 0x21, 0x40,
  0x02, 0x80, 0x21, 0x40, 0x02, 0x00, 0x70, 0xC0, 0x03, 0x00, 0x70, 0xC0, 0x02, 0x00, 0x58, 0xC0,
  0x02, 0x60, 0x58, 0x40, 0x06, 0x70, 0xC8, 0x40, 0xFE, 0xD3, 0x8C, 0x7F, 0xFC, 0xDB, 0x8C, 0x3F,
  0x18, 0x8E, 0x04, 0x18, 0x30, 0x8C, 0x07, 0x0C, 0x60, 0x80, 0x03, 0x06, 0xC0, 0x00, 0x03, 0x03,
  0x80, 0x01, 0x83, 0x01, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x0C, 0x30, 0x00,
  0x00, 0x18, 0x18, 0x00, 0x00, 0x30, 0x0C, 0x00, 0x00, 0x60, 0x06, 0x00, 0x00, 0xC0, 0x03, 0x00,
  0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};
const unsigned char co5[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\安全.bmp  --*/
  /*--  宽度x高度=32x32  --*/
  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0xF8, 0x0E, 0x00,
  0x00, 0x3F, 0xFC, 0x01, 0xF0, 0x0F, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0x30, 0x00, 0x00, 0x0C,
  0x30, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x60, 0x0C,
  0x30, 0x00, 0x70, 0x0C, 0x30, 0x00, 0x38, 0x0C, 0x30, 0x04, 0x18, 0x0C, 0x30, 0x0C, 0x0C, 0x0C,
  0x30, 0x1C, 0x0E, 0x0C, 0x30, 0x38, 0x07, 0x0C, 0x30, 0xF0, 0x03, 0x0C, 0x30, 0xE0, 0x01, 0x0C,
  0x30, 0xC0, 0x00, 0x0C, 0x60, 0x00, 0x00, 0x06, 0xE0, 0x00, 0x00, 0x06, 0xE0, 0x00, 0x00, 0x03,
  0xC0, 0x01, 0x80, 0x03, 0x80, 0x03, 0xC0, 0x01, 0x00, 0x0E, 0xE0, 0x00, 0x00, 0x3C, 0x38, 0x00,
  0x00, 0x78, 0x1E, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,

};
const unsigned char co6[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\8测距.bmp  --*/
  /*--  宽度x高度=32x32  --*/
  0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0xFE, 0x01,
  0x00, 0x00, 0x87, 0x03, 0x00, 0x80, 0x0F, 0x07, 0x00, 0xC0, 0x1F, 0x0E, 0x00, 0xE0, 0x38, 0x1C,
  0x00, 0xF0, 0x71, 0x38, 0x00, 0xF8, 0x23, 0x70, 0x00, 0x9C, 0x03, 0x70, 0x00, 0x1E, 0x07, 0xF0,
  0x00, 0x3F, 0x00, 0x78, 0x80, 0x73, 0x00, 0x3C, 0xC0, 0xE3, 0x00, 0x1E, 0xE0, 0xC3, 0x00, 0x0F,
  0x70, 0x0F, 0x80, 0x07, 0x38, 0x0E, 0xC0, 0x03, 0x7C, 0x00, 0xE0, 0x01, 0xFE, 0x00, 0xF0, 0x00,
  0xC7, 0x01, 0x78, 0x00, 0x8F, 0x03, 0x3C, 0x00, 0x0E, 0x01, 0x1E, 0x00, 0x1C, 0x00, 0x0F, 0x00,
  0x38, 0x80, 0x07, 0x00, 0x70, 0xC0, 0x03, 0x00, 0xE0, 0xE0, 0x01, 0x00, 0xC0, 0xF1, 0x00, 0x00,
  0x80, 0x7F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00,

};
const unsigned char co7[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\云台摄像头-面.bmp  --*/
  /*--  宽度x高度=32x32  --*/
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x1F, 0x00, 0x80, 0xFF, 0xFF, 0x01,
  0xE0, 0xFF, 0xFF, 0x07, 0xF0, 0xFF, 0xFF, 0x0F, 0xF0, 0xFF, 0xFF, 0x0F, 0xF0, 0x01, 0x80, 0x0F,
  0x30, 0xF8, 0x1F, 0x0C, 0x80, 0xFF, 0xFF, 0x01, 0xE0, 0x1F, 0xF8, 0x03, 0xE0, 0xC7, 0xE3, 0x07,
  0xE0, 0xE7, 0xE7, 0x07, 0xE0, 0xF3, 0xCF, 0x07, 0xC0, 0xF3, 0xCF, 0x03, 0xC0, 0x3B, 0xDC, 0x03,
  0x80, 0x1B, 0xD8, 0x01, 0x80, 0x1B, 0xD8, 0x01, 0x00, 0x3B, 0xDC, 0x00, 0x00, 0x7A, 0x5E, 0x00,
  0x00, 0xF8, 0x1F, 0x00, 0x00, 0xF8, 0x1F, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};
const unsigned char co8[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\语音.bmp  --*/
  /*--  宽度x高度=32x32  --*/
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0xF0, 0x0F, 0x00,
  0x00, 0x38, 0x1C, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x04, 0x30, 0x00,
  0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00,
  0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00, 0x40, 0x04, 0x20, 0x02, 0x40, 0x04, 0x20, 0x02,
  0x40, 0x04, 0x30, 0x02, 0x40, 0x0C, 0x30, 0x03, 0xC0, 0x08, 0x10, 0x03, 0x80, 0x18, 0x18, 0x01,
  0x80, 0xF1, 0x87, 0x01, 0x00, 0xC1, 0x83, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x00, 0x0C, 0x70, 0x00,
  0x00, 0xF8, 0x1F, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00,
  0x00, 0x80, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};




const unsigned char cz1[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\红绿灯.bmp  --*/
  /*--  宽度x高度=42x16  --*/
  /*--  宽度不是8的倍数，现调整为：宽度x高度=48x16  --*/
  0x04, 0x00, 0x01, 0x80, 0x00, 0x00, 0x04, 0x00, 0xF9, 0x81, 0xFC, 0x01, 0xD2, 0x8F, 0x00, 0x81,
  0x40, 0x00, 0x12, 0x81, 0xF2, 0xA1, 0x42, 0x00, 0x0F, 0xC1, 0x03, 0xA1, 0x42, 0x00, 0x08, 0x01,
  0xF9, 0xA7, 0x41, 0x00, 0x04, 0x81, 0x40, 0x90, 0x40, 0x00, 0x02, 0xC1, 0x4B, 0x82, 0x40, 0x00,
  0x1F, 0x01, 0x50, 0x81, 0x40, 0x00, 0x00, 0x01, 0xE0, 0x80, 0x40, 0x00, 0x00, 0x01, 0x53, 0x41,
  0x41, 0x00, 0x18, 0xC1, 0x4C, 0x46, 0x42, 0x00, 0x07, 0x01, 0x40, 0x20, 0x42, 0x00, 0xE0, 0x1F,
  0x70, 0x10, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
const unsigned char cz2[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\调速风扇.bmp  --*/
  /*--  宽度x高度=56x16  --*/
  0x02, 0x00, 0x40, 0xE0, 0x7F, 0x00, 0x01, 0xE4, 0x9F, 0x40, 0x20, 0x40, 0x00, 0x02, 0x24, 0x11,
  0xFD, 0x27, 0x50, 0xF0, 0x7F, 0x20, 0x11, 0x41, 0xA0, 0x50, 0x10, 0x40, 0xA7, 0x17, 0xF8, 0x23,
  0x49, 0xF0, 0x7F, 0x24, 0x11, 0x48, 0x22, 0x4A, 0x10, 0x00, 0xE4, 0xDF, 0x49, 0x22, 0x44, 0xD0,
  0x7B, 0x24, 0x10, 0xF9, 0x23, 0x44, 0x10, 0x42, 0xA4, 0x17, 0xE1, 0x20, 0x4A, 0x90, 0x52, 0xB4,
  0x14, 0x51, 0x21, 0x4A, 0x10, 0x63, 0xAC, 0x14, 0x49, 0x22, 0x51, 0x91, 0x52, 0xA4, 0x17, 0x45,
  0xA4, 0x50, 0x49, 0x4A, 0x20, 0x90, 0x42, 0x20, 0x80, 0x09, 0x42, 0x10, 0x5C, 0xFC, 0x17, 0x00,
  0x85, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};
const unsigned char cz3[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\环境传感.bmp  --*/
  /*--  宽度x高度=56x16  --*/
  0x00, 0x00, 0x41, 0x80, 0x10, 0x00, 0x24, 0xE0, 0x1F, 0xF9, 0x83, 0x10, 0xF8, 0x7F, 0x1F, 0x02,
  0x11, 0x81, 0xFE, 0x08, 0x04, 0x04, 0x02, 0xA1, 0x40, 0x10, 0xE8, 0x25, 0x04, 0xC1, 0xFB, 0x47,
  0x08, 0x08, 0x24, 0x04, 0x01, 0x01, 0x60, 0xFF, 0xE9, 0x15, 0x9F, 0x05, 0xF9, 0x53, 0x08, 0x28,
  0x09, 0x44, 0x09, 0x09, 0x42, 0x04, 0xE8, 0x55, 0x24, 0x11, 0xF9, 0x43, 0xFE, 0x08, 0x62, 0x04,
  0x11, 0x09, 0x42, 0x80, 0x04, 0x41, 0x1C, 0x01, 0xFB, 0x43, 0x40, 0x80, 0x00, 0x07, 0xC1, 0xA0,
  0x40, 0x28, 0x28, 0x21, 0x00, 0x01, 0x90, 0x44, 0x10, 0x28, 0x48, 0x00, 0x01, 0x0C, 0x47, 0x20,
  0xC4, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};
const unsigned char cz4[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\心率检测.bmp  --*/
  /*--  宽度x高度=56x16  --*/
  0x20, 0x00, 0x08, 0x40, 0x10, 0x00, 0x40, 0x40, 0x00, 0x10, 0x40, 0x10, 0xC8, 0x47, 0x80, 0x80,
  0xFF, 0x43, 0x28, 0x50, 0x44, 0x80, 0x00, 0x10, 0xF0, 0x44, 0x40, 0x55, 0x10, 0x40, 0x48, 0x44,
  0x82, 0x44, 0x55, 0x10, 0x80, 0x3C, 0x42, 0x7D, 0x49, 0x55, 0x12, 0x04, 0x11, 0xE1, 0x00, 0x40,
  0x55, 0x12, 0x88, 0x48, 0x62, 0x89, 0x50, 0x55, 0x12, 0x48, 0xFC, 0x54, 0x90, 0x50, 0x55, 0x12,
  0x10, 0x90, 0x40, 0x92, 0x08, 0x51, 0x11, 0xD0, 0xFF, 0x47, 0x44, 0x88, 0x42, 0x10, 0x02, 0x10,
  0x40, 0x44, 0x84, 0x44, 0x10, 0x02, 0x10, 0x40, 0x20, 0x44, 0x44, 0xE0, 0x03, 0x10, 0x40, 0xFF,
  0x21, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};
const unsigned char cz5[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\智能安防.bmp  --*/
  /*--  宽度x高度=56x16  --*/
  0x02, 0x00, 0x42, 0x00, 0x02, 0x00, 0x04, 0xBE, 0x0F, 0x41, 0x06, 0x04, 0x78, 0x08, 0x89, 0x88,
  0xC8, 0xF1, 0xFF, 0x49, 0x00, 0x88, 0xC8, 0x5F, 0x14, 0x00, 0x49, 0x7F, 0xFF, 0x08, 0x50, 0x14,
  0x02, 0x29, 0x02, 0x94, 0x08, 0x80, 0x07, 0x02, 0x28, 0x02, 0xA2, 0x8F, 0x0F, 0xF0, 0xFF, 0x49,
  0x3E, 0x01, 0x80, 0x48, 0x04, 0x21, 0x48, 0x22, 0xFC, 0x87, 0x4F, 0x82, 0x20, 0x48, 0x22, 0x04,
  0x84, 0xC8, 0xC1, 0x13, 0x48, 0x22, 0xFC, 0x87, 0x4F, 0x00, 0x0C, 0x38, 0x22, 0x04, 0x84, 0x48,
  0x04, 0x32, 0x08, 0x21, 0xFC, 0x87, 0x48, 0x84, 0x41, 0x08, 0x21, 0x04, 0x84, 0x8C, 0x77, 0x80,
  0x88, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};
const unsigned char cz6[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\测距仪.bmp  --*/
  /*--  宽度x高度=42x16  --*/
  /*--  宽度不是8的倍数，现调整为：宽度x高度=48x16  --*/
  0x00, 0x10, 0x00, 0x80, 0x08, 0x00, 0xF2, 0x91, 0xEF, 0x87, 0x10, 0x00, 0x14, 0x91, 0x28, 0x80,
  0x90, 0x00, 0x50, 0x95, 0x28, 0x40, 0x82, 0x00, 0x51, 0x95, 0x28, 0x40, 0x82, 0x00, 0x52, 0x95,
  0xEF, 0x63, 0x44, 0x00, 0x50, 0x15, 0x22, 0x52, 0x44, 0x00, 0x54, 0x95, 0x22, 0x42, 0x28, 0x00,
  0x54, 0x95, 0x2E, 0x42, 0x28, 0x00, 0x42, 0x94, 0xE2, 0x43, 0x10, 0x00, 0xA2, 0x90, 0x22, 0x40,
  0x28, 0x00, 0x21, 0x91, 0x2E, 0x40, 0x44, 0x00, 0x11, 0xD1, 0x21, 0x40, 0x82, 0x00, 0x08, 0x1C,
  0xE0, 0x47, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};
const unsigned char cz7[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\体感云台.bmp  --*/
  /*--  宽度x高度=56x16  --*/
  0x08, 0x01, 0x40, 0x02, 0x00, 0x80, 0x00, 0x08, 0x81, 0xFF, 0xC7, 0x7F, 0x80, 0x00, 0x08, 0x81,
  0x40, 0x00, 0x00, 0x40, 0x08, 0xE4, 0x9F, 0x5E, 0x02, 0x00, 0x20, 0x10, 0x04, 0x81, 0x40, 0x02,
  0x00, 0x10, 0x20, 0x86, 0x83, 0x5E, 0xF1, 0xFF, 0xF9, 0x7F, 0x85, 0x83, 0x92, 0x00, 0x02, 0x00,
  0x40, 0x44, 0x85, 0x5E, 0x05, 0x02, 0x00, 0x00, 0x44, 0x85, 0x20, 0x06, 0x01, 0xF0, 0x3F, 0x24,
  0x49, 0x10, 0x04, 0x11, 0x10, 0x20, 0xD4, 0x17, 0x08, 0x80, 0x20, 0x10, 0x20, 0x04, 0x81, 0x12,
  0x42, 0x40, 0x10, 0x20, 0x04, 0x81, 0x82, 0xE4, 0xFF, 0xF0, 0x3F, 0x04, 0x41, 0xFC, 0x04, 0x80,
  0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};
const unsigned char cz8[] U8X8_PROGMEM = {
  /*--  调入了一幅图像：C:\Users\ADMIN\Desktop\语音控制.bmp  --*/
  /*--  宽度x高度=56x16  --*/
  0xF2, 0x1F, 0x08, 0x40, 0x08, 0x40, 0x20, 0x84, 0x00, 0x10, 0x40, 0x10, 0x48, 0x20, 0x84, 0x80,
  0xFF, 0x43, 0xFE, 0xF9, 0x2B, 0xE0, 0x0F, 0x82, 0xF0, 0x02, 0x45, 0x28, 0x40, 0x08, 0x44, 0x40,
  0x48, 0x40, 0x28, 0x47, 0xC8, 0xFF, 0x47, 0x84, 0xFC, 0x2B, 0xF4, 0x1F, 0x00, 0x40, 0x02, 0x41,
  0x28, 0x04, 0x00, 0xFF, 0xC1, 0x00, 0x40, 0x28, 0x04, 0x00, 0x01, 0x71, 0xFC, 0xF8, 0x2B, 0xE4,
  0x0F, 0x01, 0x41, 0x10, 0x48, 0x2A, 0x34, 0x08, 0xFF, 0x41, 0x10, 0x48, 0x22, 0x2C, 0x08, 0x01,
  0x41, 0x10, 0x48, 0x22, 0xE4, 0x0F, 0x01, 0x41, 0x10, 0x48, 0x23, 0x20, 0x08, 0xFF, 0x71, 0xFE,
  0x41, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,


};
void setup() {

  u8g2.begin();
  pinMode(LED1, OUTPUT);
  pinMode(LED2, OUTPUT);
  pinMode(LED3, OUTPUT);
  pinMode(BEEP, OUTPUT);
  pinMode(KEY1, INPUT);
  pinMode(KEY2, INPUT);
  pinMode(KEY3, INPUT);

  myservo1.attach(DJ_X);  // 控制线连接数字9
  myservo2.attach(DJ_Y);  // 控制线连接数字8

  pinMode(leida, INPUT);
  Serial.begin(115200); // open serial port, set the baud rate to 9600 bps
  pinMode(FAN, OUTPUT);
  u8g2.clearBuffer();          // clear the internal memory


}

void loop() {
  if (zx) //执行
  {
    if (mos == 1)//红绿灯
    {
      if (LED.begin4() != 0)
      {
        Serial.println("Failed to initialize the chip , please confirm the chip connection!");
        delay(1000);
      }
      LED.setDisplayArea4(1, 2, 3, 4);
      LED.print4("H", "A", "L", "O");
      delay(1000);
      while (1)
      {

        if (sunxu == 0)
        {
          digitalWrite(12, LOW);


          digitalWrite(11, HIGH);
          if (js <= 0)
          {
            js = 5;
            sunxu = 1;
            digitalWrite(11, LOW);
          }

        }
        if (sunxu == 1)
        {



          digitalWrite(13, HIGH);
          if (js <= 0)
          {
            js = 3;
            sunxu = 2;
            digitalWrite(13, LOW);
          }


        }
        if (sunxu == 2)
        {



          digitalWrite(12, HIGH);

          if (js < 1)
          {
            js = 10;
            sunxu = 0;
            digitalWrite(11, HIGH);
            digitalWrite(12, LOW);
          }


        }


        u8g2.clearBuffer();          // clear the internal memory
        u8g2.drawXBMP(0, 0, 48, 16, cz1);
        u8g2.setFont(u8g2_font_7Segments_26x42_mn); // choose a suitable font
        u8g2.setCursor(55, 50);
        u8g2.print(js);
        if (js > 9)
        {
          LED.setDisplayArea4(3, 4);
          LED.print4(js);
        }
        else
        {
          LED.setDisplayArea4(4);
          LED.print4(js);

        }
        u8g2.sendBuffer();          // transfer internal memory to the display
        delay(1000);
        js--;
      }
    }
    else if (mos == 2)//调速风扇
    {
      while (1)
      {
        int val;
        val = analogRead(6); //connect grayscale sensor to Analog 0
        Serial.println(val, DEC); //print the value to serial
        delay(100);
        vai = val / 4;
        if (vai < 0)
          vai = 0;
        analogWrite(FAN, vai);
        u8g2.clearBuffer();          // clear the internal memory
        u8g2.setFont(u8g2_font_7Segments_26x42_mn); // choose a suitable font
        u8g2.drawXBMP(0, 0, 56, 16, cz2);
        u8g2.setCursor(30, 64);
        u8g2.print(vai);

        u8g2.sendBuffer();          // transfer internal memory to the display
      }
    }
    else if (mos == 3)//环境传感
    {

      bmp.reset();
      Serial.println("bmp read data test");
      if (bmp.begin() != BMP::eStatusOK) {
        Serial.println("bmp begin faild");
        printLastOperateStatus(bmp.lastOperateStatus);
        u8g2.clearBuffer();          // clear the internal memory
        u8g2.setFont(u8g2_font_ncenB08_tr); // choose a suitable font
        u8g2.drawStr(0, 10, "BMP280"); // write something to the internal memory
        u8g2.sendBuffer();          // transfer internal memory to the display
        delay(2000);
      }
      Serial.println("bmp begin success");
      delay(100);
      while (1)
      {
        DHT.read(DHT11_PIN);    // READ DATA
        int ld = analogRead(LIANDU);
        int sy = analogRead(SENY);

        float   temp = bmp.getTemperature();
        uint32_t    press = bmp.getPressure();
        float   alti = bmp.calAltitude(SEA_LEVEL_PRESSURE, press);
        u8g2.clearBuffer();          // clear the internal memory
        u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font

        u8g2.setCursor(0, 10);
        u8g2.print("Humidity: ");
        u8g2.print(DHT.humidity);

        u8g2.setCursor(0, 20);
        u8g2.print("Temperature: ");
        u8g2.print(DHT.temperature);

        u8g2.setCursor(0, 30);
        u8g2.print("light: ");
        u8g2.print(ld);

        u8g2.setCursor(0, 40);
        u8g2.print("voice: ");
        u8g2.print(sy);

        u8g2.setCursor(0, 50);
        u8g2.print("pressure: ");
        u8g2.print(press);

        u8g2.setCursor(0, 60);
        u8g2.print("altitude: ");
        u8g2.print(alti);

        u8g2.sendBuffer();          // transfer internal memory to the display


      }
    }
    else if (mos == 4)//心率检测
    {
      Serial.begin(115200);
      Serial.println("Initializing...");

      // Initialize sensor
      if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) //Use default I2C port, 400kHz speed
      {
        Serial.println("MAX30105 was not found. Please check wiring/power. ");
        u8g2.clearBuffer();          // clear the internal memory
        u8g2.setFont(u8g2_font_ncenB08_tr); // choose a suitable font
        u8g2.drawStr(0, 10, "MAX30102"); // write something to the internal memory
        u8g2.sendBuffer();          // transfer internal memory to the display
        delay(2000);
      }
      Serial.println("Place your index finger on the sensor with steady pressure.");

      particleSensor.setup(); //Configure sensor with default settings
      particleSensor.setPulseAmplitudeRed(0x0A); //Turn Red LED to low to indicate sensor is running
      particleSensor.setPulseAmplitudeGreen(0); //Turn off Green LED
      int js = 0;
      while (1)
      {
        long irValue = particleSensor.getIR();

        if (checkForBeat(irValue) == true)
        {
          //We sensed a beat!
          long delta = millis() - lastBeat;
          lastBeat = millis();

          beatsPerMinute = 60 / (delta / 1000.0);

          if (beatsPerMinute < 255 && beatsPerMinute > 20)
          {
            rates[rateSpot++] = (byte)beatsPerMinute; //Store this reading in the array
            rateSpot %= RATE_SIZE; //Wrap variable

            //Take average of readings
            beatAvg = 0;
            for (byte x = 0 ; x < RATE_SIZE ; x++)
              beatAvg += rates[x];
            beatAvg /= RATE_SIZE;
          }
        }



        //        Serial.print("IR=");
        //        Serial.print(irValue);
        //        Serial.print(", BPM=");
        //        Serial.print(beatsPerMinute);
        //        Serial.print(", Avg BPM=");
        //        Serial.print(beatAvg);
        js++;
        if (js > 100)
        {
          js = 0;
          u8g2.clearBuffer();          // clear the internal memory
          u8g2.drawXBMP(16, 16, 32, 32, co4);
          u8g2.setFont(u8g2_font_7Segments_26x42_mn); // choose a suitable font
          u8g2.setCursor(55, 50);
          u8g2.print(beatAvg);

          u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font

          u8g2.setCursor(0, 64);
          u8g2.print("IR=");
          u8g2.print(irValue);
          u8g2.print(", BPM=");
          u8g2.print(beatsPerMinute);

          u8g2.sendBuffer();          // transfer internal memory to the display
        }
        if (irValue < 50000)
        {
          u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font

          u8g2.setCursor(0, 64);
          u8g2.print(" No finger?           ");


          u8g2.sendBuffer();          // transfer internal memory to the display


        }
      }
    }
    else if (mos == 5)//智能安防
    {

      Serial2.begin(9600);             //初始化串口并设置波特率为115200
      int zuantai = 0;
      int qt_zt = 140, hy_zt = 800;
      while (1)
      {
        if (Serial2.available() > 0)
        {
          int REED = Serial2.read();
          if (REED == 'A')
          {
            zuantai = 1;
          }
          else if (REED == 'B')
          {
            zuantai = 0;
          }

        }

        int qt = analogRead(qiti);
        int hy = analogRead(huoyan);


        u8g2.clearBuffer();          // clear the internal memory
        u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font

        if (digitalRead(leida) == HIGH)
        {
          digitalWrite(LED1, HIGH);
          u8g2.setFont(u8g2_font_streamline_interface_essential_id_t);      //特殊图形，见图标
          u8g2.drawGlyph(72, 30, 0x0034);  //dec 9731/hex 2603 Snowman （对应下图的位置）
          u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font
        }
        else
        {
          digitalWrite(LED1, LOW);
        }
        if (zuantai)
        {
          u8g2.setFont(u8g2_font_streamline_interface_essential_key_lock_t);      //特殊图形，见图标
          u8g2.drawGlyph(95, 30, 0x0036);  //dec 9731/hex 2603 Snowman （对应下图的位置）
          u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font

        }

        if (hy < hy_zt || (digitalRead(leida) == HIGH && zuantai == 1) || qt > qt_zt)
        {
          digitalWrite(BEEP, HIGH);
          u8g2.setFont(u8g2_font_streamline_interface_essential_circle_triangle_t);      //特殊图形，见图标
          u8g2.drawGlyph(72, 60, 0x0030);  //dec 9731/hex 2603 Snowman （对应下图的位置）
          u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font
        }
        else
        {
          digitalWrite(BEEP, LOW);
        }
        if (qt > qt_zt)
        {
          analogWrite(FAN, 255);
          u8g2.setFont(u8g2_font_streamline_interface_essential_action_t);      //特殊图形，见图标
          u8g2.drawGlyph(95, 60, 0x0036);  //dec 9731/hex 2603 Snowman （对应下图的位置）
          u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font
        }
        else
        {
          analogWrite(FAN, 0);
        }

        u8g2.setCursor(0, 30);
        u8g2.print("flame: ");
        u8g2.print(hy);


        u8g2.setCursor(0, 40);
        u8g2.print("Gas: ");
        u8g2.print(qt);

        u8g2.sendBuffer();          // transfer internal memory to the display
      }
    }
    else if (mos == 6)//测距仪
    {

      pinMode(ECHOPIN, INPUT);
      pinMode(TRIGPIN, OUTPUT);
      while (1)
      {
        digitalWrite(TRIGPIN, LOW); // Set the trigger pin to low for 2uS
        delayMicroseconds(2);
        digitalWrite(TRIGPIN, HIGH); // Send a 10uS high to trigger ranging
        delayMicroseconds(20);
        digitalWrite(TRIGPIN, LOW); // Send pin low again
        distance = pulseIn(ECHOPIN, HIGH) / 58; // Read in times pulse

        u8g2.clearBuffer();          // clear the internal memory
        u8g2.drawXBMP(0, 0, 48, 16, cz6);
        u8g2.setFont(u8g2_font_7Segments_26x42_mn); // choose a suitable font
        u8g2.setCursor(10, 64);
        u8g2.print(distance);
        u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font
        u8g2.setCursor(110, 64);
        u8g2.print("cm");
        u8g2.sendBuffer();          // transfer internal memory to the display
      }

    }
    else if (mos == 7)//体感云台
    {
      u8g2.clearBuffer();          // clear the internal memory

      u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font
      u8g2.setCursor(0, 10);
      u8g2.print("MPU6050...");
      u8g2.sendBuffer();          // transfer internal memory to the display
      // join I2C bus (I2Cdev library doesn't do this automatically)
#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
      Wire.begin();
      Wire.setClock(400000); // 400kHz I2C clock. Comment this line if having compilation difficulties
#elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE
      Fastwire::setup(400, true);
#endif

      Serial.begin(115200);
      while (!Serial); // wait for Leonardo enumeration, others continue immediately

      Serial.println(F("Initializing I2C devices..."));
      mpu.initialize();


      // load and configure the DMP
      Serial.println(F("Initializing DMP..."));
      devStatus = mpu.dmpInitialize();

      // supply your own gyro offsets here, scaled for min sensitivity
      mpu.setXGyroOffset(220);
      mpu.setYGyroOffset(76);
      mpu.setZGyroOffset(-85);
      mpu.setZAccelOffset(1788); // 1688 factory default for my test chip

      // make sure it worked (returns 0 if so)
      if (devStatus == 0) {
        // Calibration Time: generate offsets and calibrate our MPU6050
        mpu.CalibrateAccel(6);
        mpu.CalibrateGyro(6);
        mpu.PrintActiveOffsets();
        // turn on the DMP, now that it's ready
        Serial.println(F("Enabling DMP..."));
        mpu.setDMPEnabled(true);

        // enable Arduino interrupt detection
        Serial.print(F("Enabling interrupt detection (Arduino external interrupt "));
        Serial.print(digitalPinToInterrupt(INTERRUPT_PIN));
        Serial.println(F(")..."));
        attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN), dmpDataReady, RISING);
        mpuIntStatus = mpu.getIntStatus();

        // set our DMP Ready flag so the main loop() function knows it's okay to use it
        Serial.println(F("DMP ready! Waiting for first interrupt..."));
        dmpReady = true;

        // get expected DMP packet size for later comparison
        packetSize = mpu.dmpGetFIFOPacketSize();
      } else {
        // ERROR!
        // 1 = initial memory load failed
        // 2 = DMP configuration updates failed
        // (if it's going to break, usually the code will be 1)
        Serial.print(F("DMP Initialization failed (code "));
        Serial.print(devStatus);
        Serial.println(F(")"));
      }
      //for (int i = 0; i < 8; i++)rotate(cube[i], 0.1, 0.1, 0.1); //旋转每个点
      float m_x, m_y, m_z;
      float am_x, am_y, am_z;
      int dj_qiy = 0;
      float dj_x, dj_y, dj_z;
      while (1)
      {

        // if programming failed, don't try to do anything
        if (!dmpReady) return;
        // read a packet from FIFO
        if (mpu.dmpGetCurrentFIFOPacket(fifoBuffer)) { // Get the Latest packet
          // display Euler angles in degrees
          mpu.dmpGetQuaternion(&q, fifoBuffer);
          mpu.dmpGetGravity(&gravity, &q);
          mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);
          am_x = ypr[0] * 180 / M_PI;
          am_y = ypr[1] * 180 / M_PI;
          am_z = ypr[2] * 180 / M_PI;

          Serial.print("ypr\t");
          Serial.print(am_x);
          Serial.print("\t");
          Serial.print(am_y);
          Serial.print("\t");
          Serial.println(am_z);
          for (int i = 0; i < 8; i++)rotate(cube[i], (m_z - am_z) * 0.1, (m_y - am_y) * 0.1 , (m_x - am_x) * 0.1); //旋转每个点am_z - m_z

          if (m_x != am_x)
            m_x = am_x;
          if (m_y != am_y)
            m_y = am_y;
          if (m_z != am_z)
            m_z = am_z;
        }
        u8g2.clearBuffer();          // clear the internal memory

        u8g2.setFont(u8g2_font_6x10_mf  ); // choose a suitable font
        u8g2.setCursor(0, 10);
        u8g2.print("x:");
        u8g2.print(am_y);

        u8g2.setCursor(0, 20);
        u8g2.print("y:");
        u8g2.print(am_z);

        u8g2.setCursor(0, 30);
        u8g2.print("z:");
        u8g2.print(am_x);


        for (int i = 0; i < 24; i += 2) { //绘制立方体
          u8g2.drawLine(64 + cube[lineid[i] - 1][0], 32 + cube[lineid[i] - 1][1], 64 + cube[lineid[i + 1] - 1][0], 32 + cube[lineid[i + 1] - 1][1]);
        }



        if (digitalRead(KEY2) == HIGH)
        {
          delay(100);
          if (digitalRead(KEY2) == HIGH)
          {
            dj_qiy = !dj_qiy;
            dj_x = am_x;
            dj_y = am_y;
          }
        }
        if (dj_qiy)
        {
          if (digitalRead(KEY3) == HIGH)
          {
            delay(100);
            if (digitalRead(KEY3) == HIGH)
            {

              dj_x = am_x;
              dj_y = am_y;
            }
          }
          myservo1.write(180 - ((dj_x - am_x) + 90));        // 舵机角度写入
          myservo2.write(180 - ((dj_y - am_y) + 90));        // 舵机角度写入
          u8g2.setCursor(0, 60);

          u8g2.print(180 - ((dj_x - am_x) + 90));
          u8g2.print(" / ");
          u8g2.print(180 - ((dj_y - am_y) + 90));

        }
        u8g2.sendBuffer();          // transfer internal memory to the display

      }

    }
    else if (mos == 8)//语音控制
    {
      u8g2.clearBuffer();
      u8g2.drawXBMP(0, 0, 56, 16, cz8);
      u8g2.sendBuffer();


      while (1)
      {
        if (Serial.available() > 0)
        {
          int REED = Serial.read();
          if (REED == 'A')
          {
            digitalWrite(LED1, HIGH);   // turn the LED on (HIGH is the voltage level)
          }
          else if (REED == 'B')
          {
            digitalWrite(LED1, LOW);   // turn the LED on (HIGH is the voltage level)
          }
          else if (REED == 'C')
          {
            analogWrite(FAN, 255);
          }
          else if (REED == 'D')
          {
            analogWrite(FAN, 0);
          }
          else if (REED == 'E')
          {
            DSP = 1;
          }
        }


        if (DSP == 1)
        {
          DHT.read(DHT11_PIN);    // READ DATA
          u8g2.clearBuffer();
          u8g2.setFont(u8g2_font_ncenB14_tr);
          u8g2.drawXBMP(0, 0, 56, 16, cz8);
          u8g2.setCursor(0, 40);    //设置光标处
          u8g2.print("TEM:");
          u8g2.print(DHT.temperature);
          u8g2.setCursor(0, 64);    //设置光标处
          u8g2.print("HUM:");
          u8g2.print(DHT.humidity);
          u8g2.sendBuffer();
        }
      }

    }

  }
  else//选择
  {
    u8g2.clearBuffer();          // clear the internal memory
    u8g2.setFont(u8g2_font_ncenB08_tr); // choose a suitable font
    //u8g2.drawStr(0, 10, "Hello World!"); // write something to the internal memory
    u8g2.setCursor(64, 28);
    u8g2.print(mos);
    switch (mos)
    {

      case 1: u8g2.drawXBMP(16, 16, 32, 32, co1); u8g2.drawXBMP(64, 32, 48, 16, cz1); break;
      case 2: u8g2.drawXBMP(16, 16, 32, 32, co2); u8g2.drawXBMP(64, 32, 56, 16, cz2); break;
      case 3: u8g2.drawXBMP(16, 16, 32, 32, co3); u8g2.drawXBMP(64, 32, 56, 16, cz3); break;
      case 4: u8g2.drawXBMP(16, 16, 32, 32, co4); u8g2.drawXBMP(64, 32, 56, 16, cz4); break;
      case 5: u8g2.drawXBMP(16, 16, 32, 32, co5); u8g2.drawXBMP(64, 32, 56, 16, cz5); break;
      case 6: u8g2.drawXBMP(16, 16, 32, 32, co6); u8g2.drawXBMP(64, 32, 42, 16, cz6); break;
      case 7: u8g2.drawXBMP(16, 16, 32, 32, co7); u8g2.drawXBMP(64, 32, 56, 16, cz7); break;
      case 8: u8g2.drawXBMP(16, 16, 32, 32, co8); u8g2.drawXBMP(64, 32, 56, 16, cz8); break;
      default: break;
    }
    u8g2.sendBuffer();          // transfer internal memory to the display
    if (digitalRead(KEY2) == HIGH)
    {
      delay(100);
      if (digitalRead(KEY2) == HIGH)
      {
        zx = 1;
      }
    }
    if (digitalRead(KEY1) == HIGH)
    {
      delay(100);
      if (digitalRead(KEY1) == HIGH)
      {
        mos--;
        if (mos < 1)
        {
          mos = 1;
        }
      }
    }
    if (digitalRead(KEY3) == HIGH)
    {
      delay(100);
      if (digitalRead(KEY3) == HIGH)
      {
        mos++;
        if (mos > mos_m)
        {
          mos = mos_m;
        }
      }
    }
  }


}
